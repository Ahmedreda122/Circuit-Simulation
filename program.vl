// We've Used 12 Component as following => Six 4x1 multiplexers, Three xor gates, Three full adders

// Half Adder (Adding one bit to another) and Returning the sum of them and the carry
module half_adder(output sum, output carry, input a, input b);
    // First Adding a & b by xoring them and store the result in "sum" as an output
    xor(sum, a, b);
    // Second Calculate the carry of adding a to b and the store the result in "carry" as an output
    and(carry, a, b);
endmodule

// FullAdder: Adding three bits and returing the result as "sum" and "carry"
module full_adder(output sum, output carry, input x, input y, input z);
    // Wires to transfer values from one component to another
    wire s1, c1, c2;
    // First, Add x and y using half adder the store the summation and carry in "s1" & "c1" respectively
    half_adder h1(s1, c1, x, y);
    // Second, Add s1(result of adding x & y) to z using half adder the store the summation and carry in "sum"(as an output) & "c2" respectively
    half_adder h2(sum, c2, s1, z);
    // Lastly, Calculate the carry of adding x ,y and z by ORing c1 & c2 and store the result in "carry" as an output
    or(carry, c1, c2);
endmodule

module TwoxOneMUX(output res, input D0, input D1, input S);
// Wires to transfer values from one component to another
    wire res1, res2;
    and(res1, D0, ~S); //0
    and(res2, D1, S); // 1
    or(res, res1, res2);
endmodule

module FourxOneMUX(output res, input D0, input D1, input D2, input D3, input S0, input S1);
// Wires to transfer values from one component to another
    wire res1, res2, res3, res4;
    and(res1, D0, ~S0, ~S1); // 0 0
    and(res2, D1, S0, ~S1); //  0 1
    and(res3, D2, ~S0, S1); //  1 0
    and(res4, D3, S0, S1); //   1 1
    or(res, res1, res2, res3, res4);
endmodule

// The Main Circuit which take the G as 3 bit output and provide a carry
// Takes A, B which is 3 bit signed numbers, S0, S1 the selectors to operations
module mainCircuit(output signed[2:0] G, output carry, input signed[2:0] A, input signed[2:0] B, input S0, input S1);
    // Wires to transfer values from one component to another
    wire mux1Output, mux2Output, mux3Output, mux4Output, mux5Output, mux6Output;
    wire xor1Output, xor2Ouput, xor3Ouput; 
    wire c1, c2;

    // First We Choose From A[0] and B[0] depending on the selectors
    // if S0 & S1 are equal to 1 then outputs B[0] which is the first bit of 'B', Otherwise outputs A[0] 
    // Then store that output in mux1Output
    FourxOneMUX mux1(mux1Output, A[0], A[0], A[0], B[0], S0, S1);
    assign xor1Output = S1 ^ mux1Output;

    FourxOneMUX mux2(mux2Output, A[1], A[1], A[1], B[1], S0, S1);
    assign xor2Output = S1 ^ mux2Output;

    FourxOneMUX mux3(mux3Output, A[2], A[2], A[2], B[2], S0, S1);
    assign xor3Output = S1 ^ mux3Output;
    
    FourxOneMUX mux4(mux4Output, 1'b1, B[0], B[0], 1'b1, S0, S1);
    FourxOneMUX mux5(mux5Output, 1'b0, B[1], B[1], 1'b0, S0, S1);
    FourxOneMUX mux6(mux6Output, 1'b0, B[2], B[2], 1'b0, S0, S1);
    //(output sum, output carry, input x, input y, input z);
    full_adder f1(G[0], c1, xor1Output, mux4Output, S1);
    full_adder f2(G[1], c2, xor2Output, mux5Output, c1);
    full_adder f3(G[2], carry, xor3Output, mux6Output, c2);
endmodule

`timescale 1ns/1ps

module testbench;

    // Inputs
    reg [2:0] A;
    reg [2:0] B;
    reg S0, S1;

    // Outputs
    wire [2:0] G;
    wire carry;

    // Instantiate the mainCircuit module
    mainCircuit dut (
        .G(G),
        .carry(carry),
        .A(A),
        .B(B),
        .S0(S0),
        .S1(S1)
    );

    // Clock generation
    reg clk = 0;
    always #5 clk = ~clk;

    // Test stimulus
    initial begin
        $display("Testing mainCircuit module");
        $display("-------------------------");

        // Loop for different test cases
        repeat(40) begin
            // Assign test values to inputs A and B
            A = $random;
            B = $random;
            S0 = $random;
            S1 = $random;

            // Display input values
            $display("Input: A = %b, B = %b, S1 = %b, S0 = %b", A, B, S1, S0);

            // Apply inputs
            #1;

            // Display output values
            $display("Output: G = %b, Carry = %b", G, carry);
            $display("-------------------------");

            // Wait before next test case
            #10;
        end
        // End simulation
        $finish;
    end

endmodule
